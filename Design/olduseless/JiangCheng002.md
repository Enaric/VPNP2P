现有serverA,B,C,D,E 5台服务器ClientA与ClientB加入打洞
分为3个步骤：1.首先确定IP，2.其次确定路由出入的端口规则，3.如果打洞成功则在各个server进行记录

1.确定IP
    clientA向serverA,serverB,serverC,serverD,serverE这5个不同环境服务器的9930端口发送请求，server之间共享消息，发送至serverA，serverA一共能收到5条消息，并且知道每条消息的【ip:port】，记录为
    -------------------------------------------------------------------------------
    clientA | A ip1:port1 | B ip2:port2 | C ip3:port3 | D ip4:port4 | E ip5:port5 |
    -------------------------------------------------------------------------------
    对这5条消息的ip进行讨论
    如果这5条消息的ip相同，则选取这个唯一的ip作为clientA的打洞ip
    如果这5条消息的ip不同，假设如下，则可以认为是以下情况，即对于clientA而言，有两层路由
    ----+----    IP：202.58.12.102   [3个]
        |        
    ----+----    IP：211.1.12.102    [2个]
        |
     clientA


    clientB进行同样的操作，得到
    -------------------------------------------------------------------------------
    clientB | A ip1:port1 | B ip2:port2 | C ip3:port3 | D ip4:port4 | E ip5:port5 |
    -------------------------------------------------------------------------------
    如果clientB的5条消息的ip相同，则选取这个唯一的ip作为clientB的打洞ip
    如果clientB的5条消息的ip不同，假设如下，则可以认为是以下情况，即对于clientB而言，有两层路由


  ---------------------------------------------------------------------------讨论有出现多层路由的情况---------------------------------------------------------------------------
    如果clientB向clientA的内层路由上的服务器发送消息得到的IP唯一，则把这个IP作为clientB的打洞IP，即clientA向这个IP进行打洞。反之同理。

    如果clientB向clientA的内层路由上的服务器发送消息得到的IP不唯一，比如clientA的内层路由上有serverA,B,但是clientB向serverA,B发送消息产生IP1，IP2，IP1！=IP2，此时，无法确认clientB向clientA发送    ----+----    IP：204.58.12.102   [3个]
        |        
    ----+----    IP：213.1.12.102    [2个]
        |
     clientB请求时，clientA显示的是哪个IP，则把这两个IP同时作为clientB的打洞IP，即clientA向这两个IP进行打洞。
    记录下打洞使用的IP号和显示这个IP号的serverX


2.确定路由出入的端口规则
    用clientA向serverA的9930，9931，9932这三个端口发送一次请求
    serverA可以收到3条来自clientA的请求，获取这3条请求的ip地址和端口号，分别是【ip1:port1】,【ip2:port2】,【ip3:port3】
    [判断ip1，ip2，ip3是否相等]
    在通常情况下，clientA所在的网络环境没有改变，这3条请求的ip应该是相同的，如果不相同，则作废这三条请求，用serverA的9933端口发送命令给clientA，提示clientA端重新发送。

  ------------------------------------------------------------------------------路由出性质判断------------------------------------------------------------------------------
    [判断port1，port2，port3是否相等]
    1.如果这3条请求的3个端口号完全相同，可以认为在clientA侧，路由出时，端口号固定不变
    2.如果这3条请求的3个端口号之间存在一定规律变化(22345，22346，22347)，可以认为在clientA侧，路由出时，端口号以一定规律变化(+1)
    3.如果这3条请求的3个端口号之间杂乱无章，可以认为在clientA侧，路由出时，端口号随机分配
    在serverA端记录下clientA的3条请求，记录形式可以是 
    ---------------------------------------------------------------
    clientA | out  | type| ip1:port1  |  ip2:port2  |  ip3:port3  |
    ---------------------------------------------------------------
    记录完毕后，发送给其他server进行信息共享

  ------------------------------------------------------------------------------路由入性质判断------------------------------------------------------------------------------
    如果ip1，ip2，ip3完全相等，用serverA的9930，9934，9935各发送一条返回消息给clientA，消息内容为某一个特定信号(ASDFGH);同时serverA发送信号给serverB，提示serverB发送消息给clientA，serverB在接收到serverA的提示后，以9930端口向clientA发送一条请求，消息内容为某一个特定信号(ASDFGH)
    在clientA端,如果接收到请求内容为ASDFGH的消息，则发送接收到消息的【ip:port ASDFGH】给serverA【一共会发送4条消息给clientA,如果中间clientA的网络环境发生变化，比如接收到serverA9930端口发来的消息后，网络环境发生变化或者波动，不能接收到第2，3，4条，这时候只发送第一条给serverA，导致性质判断出错】
    [在serverA端进行clientA的性质判断]
    从接收到第一条来自clientA的包含ASDFGH的消息起，在1分钟内，进行一下判断
    1.如果接收到了clientA的4条消息包中包含ASDFGH的消息，消息包中含有serverA的9930，9934，9935端口以及serverB的9930端口信息，可以判断clientA路由入时，对收到的所有信息进行转发
    2.如果接收到了clientA的3条消息包中包含ASDFGH的消息，消息包中含有serverA的9930，9934，9935端口信息，可以判断clientA路由入时，仅对相同的IP发来的信息进行转发
    3.如果接收到了clientA的1条消息包中包含ASDFGH的消息，消息包中仅有serverA的9930端口信息，可以判断clientA路由入时，仅对相同的IP且相同port发来的信息进行转发
    4.在1分钟结束后，如果是任意其他情况，可以判断为网络波动，重新对clientA的路由入性质进行判断，直到是以上3种情况
    记录下接收到的消息情况，记录形式可以是 
    --------------------------------------------------------------------------------
    clientA | in | type| serverA:9930 | serverA:9934 | serverA:9935 | serverB:9930 |
    --------------------------------------------------------------------------------
    记录完毕后，发送给其他server进行信息共享


  ------------------------------------------------------------------------------路由性质记录------------------------------------------------------------------------------
    此时对clientA的路由性质判断完成(需要使用到的server是serverA和serverB)
    [clientB进行同样的操作]
    对clientA，clientB的信息收集完毕，在serverA端将收集到的信息表(如下)发送给clientA和clientB，开始clientA和clientB之间的打洞。
    ---------------------------------------------------------------
    clientA | out  | type| ip1:port1  |  ip2:port2  |  ip3:port3  |
    ---------------------------------------------------------------
    --------------------------------------------------------------------------------
    clientA | in | type| serverA:9930 | serverA:9934 | serverA:9935 | serverB:9930 |
    --------------------------------------------------------------------------------
    ---------------------------------------------------------------
    clientB | out  | type| ip1:port1  |  ip2:port2  |  ip3:port3  |
    ---------------------------------------------------------------
    --------------------------------------------------------------------------------
    clientB | in | type| serverA:9930 | serverA:9934 | serverA:9935 | serverB:9930 |
    --------------------------------------------------------------------------------


  ------------------------------------------------------------------------------根据路由规则进行打洞------------------------------------------------------------------------------
    对于clientB端的路由入性质，clientA端的路由出性质进行考虑
    1.如果clientB的路由入性质是对相同的IP发来的信息进行转发，或对收到的所有信息进行转发，则clientA直接对clientB进行扫描(相同ip下，clientB都能收到)，包的内容为key。
    2.如果clientB的路由入性质是仅对相同的IP且相同port发来的信息进行转，clientA的路由出性质是固定不变，则clientA直接对clientB进行扫描，包的内容为key。
    3.如果clientB的路由入性质是仅对相同的IP且相同port发来的信息进行转，clientA的路由出性质是按一定规律变化(port+1)，在相互扫描的情况下，如果clientA的25530端口发送了请求给clientB的21329端口，之后短时间内clientB的21329端口发送了请求给clientA的25530端口，此时clientA的端口已经发生变化，导致打洞失败。初步的想法是，clientA端放慢发送速度，使得端口变化缓慢，在端口没有发生变化的情况下，有尽可能多的请求从clientB发向clientA。并且可以合理利用clientA端路由出的变化规则，计算变化一次的时间T1，打洞经过的时间Ts，来判断clientA当前使用的端口，在clientB接收到clientA发来的消息后，向clientA当前使用的端口及其附近端口发送消息。包的内容都为key。
    4.如果clientB的路由入性质是仅对相同的IP且相同port发来的信息进行转，clientA的路由出性质是随机变化，这种情况目前初步的想法是clientA端放慢发送速度，使得端口变化缓慢，在端口没有发生变化的情况下，有尽可能多的请求从clientB发向clientA。包的内容都为key。
    (对于clientA端的路由入性质，clientB端的路由出性质进行同样考虑)

3.打洞成功后
  如果打洞成功，clientA与clientB关闭打洞线程，转为发送心跳包的线程，并向serverA发送打洞成功的信号，在serverA端记录已经打洞成功的client和他们的端口号，记录形式可以是           
  -------------------------------------------
  clientA | ip:port | clientB | ip:port | key
  -------------------------------------------
  serverA在更新完毕打洞成功的client信息后，发送打洞表给其他server进行表的更新


serverID -> serverIP
[clientID, serverID] -> clientIP
clientIP -> [routerOutType, routerInType]
打通后
[clientName1, clientName2] -> [clientIP1, clientIP2]



struct client{
  clientName
  serverName
  ////////
  clientIP
  routerOutType
  routerInType
}

struct record {
  clientName1
  clientName2
  ////////
  IP1:port1, key1
  IP2:port2, key2
}
  

  


  table
  clientName IP1 IP2 IP3 IP4 IP5


  table
  clientName RouterType serverName IP


  table 
  clientName1 IP port clientName2 IP port key

